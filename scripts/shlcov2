#!/usr/bin/env python
import optparse
import os
import os.path
import re
import shcov.file
import shcov.config
import shcov.utils
import sys
import time
from lxml.etree import tostring as toxml
from lxml.builder import E as tag
from operator import attrgetter


class ShcovFileStats(object):
    """
    Object that calculates the number of covered and uncovered lines
    for a single file.

    It gives you the following members:

    * **sourcefile** The source object that we calc coverage on.
    * **executed_lines** The number of executed lines.
    * **total_lines** The total number of lines.
    * **sourcecode** A list of tuples in the following format:
      [
        (LINE_XXXX, "my source code"),
        (LINE_XXXX, "my_second source code line")
        ]
    """

    LINE_COV = 0
    LINE_UNCOV = 1
    LINE_NOCODE = 2

    # Regexp to match functions
    fn_regexp = re.compile(
        "\A(function[\t, ]+)*[a-z,A-Z,_]+[a-z,A-Z,_,0-9]*[\t, ]*\([\t, ]*\)[\t, ]*")
    brace_regexp = re.compile("\A(\{|\}){1}")

    else_then_done_regexp = re.compile("\A(else|then|fi|done|esac|do|;;){1}\\b")
    case_nr_regexp = re.compile("\A(([\',\",0-9,a-z,A-Z,_, ]+)|\*{1})\){1}\\Z")
    heredoc_regexp = re.compile(".*<<-?\'?([a-zA-Z]+)\'?")

    def __init__(self, sourcefile):
        self.total_lines = 0
        self.executed_lines = 0
        self.sourcefile = sourcefile

        source_data = shcov.utils.read_file(sourcefile.get_source_path())
        self.sourcecode = []

        nr = 1
        previousLineIsContinued = False
        heredoc_end = False
        heredoc_cnt = 0
        for line in source_data.splitlines():
            if self.line_is_code(line):
                self.total_lines = self.total_lines + 1
                if nr in sourcefile.lines or previousLineIsContinued:
                    self.executed_lines = self.executed_lines + 1
                    self.sourcecode.append((ShcovFileStats.LINE_COV, line))
                else:
                    self.sourcecode.append((ShcovFileStats.LINE_UNCOV, line))
            else:
                self.sourcecode.append((ShcovFileStats.LINE_NOCODE, line))

            if line.endswith("\\"):
                previousLineIsContinued = True
            elif ShcovFileStats.heredoc_regexp.match(line):
                previousLineIsContinued = True
                heredoc_end = ShcovFileStats.heredoc_regexp.match(line).groups()[0]
                # If the line has been executed, use the same count
                # for the rest of the here-document.
                if nr in sourcefile.lines:
                    heredoc_cnt = sourcefile.lines[nr]
                else:
                    heredoc_cnt = 0
            elif heredoc_end:
                # If the initial line was executed, add the rest of the
                # here-document lines to executed lines.
                if nr not in sourcefile.lines and heredoc_cnt > 0:
                    sourcefile.lines[nr] = heredoc_cnt
                if line == heredoc_end:
                    heredoc_end = False
            else:
                previousLineIsContinued = False

            nr = nr + 1

    def line_is_code(self, line):
        tmp = line.strip()
        if tmp.startswith('#'):
            return False
        # Functions and braces
        if tmp.startswith("function") or ShcovFileStats.fn_regexp.match(tmp) or \
                ShcovFileStats.brace_regexp.match(tmp):
            return False
        # fi/else/esac etc
        if ShcovFileStats.else_then_done_regexp.match(tmp):
            return False
        if ShcovFileStats.case_nr_regexp.match(tmp):
            return False
        # Empty string
        if tmp == "":
            return False
        return True


class ShcovReport(object):
    """
    Class that reads the coverage files and the source code and produces a report in
    several formats.
    """

    html_start = """
<html>
  <head>
    <style>
body {
  font-family:      sans-serif;
}

table.files th {
  text-align:       center;
  color:            #FFFFFF;
  background-color: #6688D4;
  font-size:        120%;
  font-weight:      bold;
}

table.files td {
  text-align:       left;
  padding-left:     10px;
  padding-right:    20px;
  color:            #284FA8;
  background-color: #DAE7FE;
  font-family:      monospace;
}

table.info th {
  text-align:       right;
  font-weight:      bold;
}

div.meter {
  display: block;
  width: 100px;
  height: 10px;
  border-style: solid;
  border-width: 1px;
  border-color: black;
  background-color: white;
}

div.meter > div {
  display: block;
  height: 10px;
  padding: 0px;
  margin: 0px;
  background-color: green;
}

span.lineno {
  background-color: #efe383;
  padding: 0px 3px;
}

span.cov {
  background-color: #cad7fe;
}

span.uncov {
  background-color: #ff6230;
}

    </style>
  </head>
  <body>
"""
    html_end = """
  </body>
</html>
"""

    def __init__(self, script_base, data_dir, out_dir):
        self.script_base = script_base
        self.data_dir = data_dir
        self.out_dir = out_dir
        self.files = []
        self.file_stats = []
        self.total_lines = 0
        self.executed_lines = 0

    def process(self):
        if not os.path.exists(self.out_dir):
            os.mkdir(self.out_dir)

        for root, dirs, files in os.walk(self.data_dir, topdown=False):
            for name in files:
                path = os.path.join(root, name)
                try:
                    sourcefile = shcov.file.load(path, script_base=self.script_base)
                    self.files.append(sourcefile)
                    self.file_stats.append(ShcovFileStats(sourcefile))
                except IOError, msg:
                    print("IGNORING %s" % path)

        self.file_stats = sorted(self.file_stats, key=attrgetter("sourcefile.path"))

        for filestats in self.file_stats:
            self.total_lines = self.total_lines + filestats.total_lines
            self.executed_lines = self.executed_lines + filestats.executed_lines

    def text(self):
        with open(os.path.join(self.out_dir, "report.txt"), "w+") as f:
            for filestats in self.file_stats:
                f.write("%s %f\n" % (filestats.sourcefile.path, (float(filestats.executed_lines) / float(filestats.total_lines)) * 100))

    def flat_html(self):
        # Create the main index.html file with a listing of all the files.
        with open(os.path.join(self.out_dir, "index.html"), "w+") as f:
            f.write(ShcovReport.html_start)
            coverage = ((float(self.executed_lines) / float(self.total_lines)) * 100)
            div = tag.div(
                tag.h1("SHCOV"),
                tag.hr(),
                tag.table(
                    tag.tr(tag.th("Date:"), tag.td(time.strftime("%Y-%m-%d"))),
                    tag.tr(tag.th("Code covered:"), tag.td("%.1f%%" % coverage)),
                    tag.tr(tag.th("Instrumented lines:"), tag.td(str(self.total_lines))),
                    tag.tr(tag.th("Executed lines:"), tag.td(str(self.executed_lines))),
                    {"class": "info"}
                    ),
                tag.hr()
                )
            f.write(toxml(div, pretty_print=True))

            table = tag.table(
                tag.thead(
                    tag.th("Filename"),
                    tag.th("Coverage", colspan="3")),
                {"class": "files"}
                )
            tbody = tag.tbody()
            table.append(tbody)
            for filestats in self.file_stats:
                coverage = (float(filestats.executed_lines) / float(filestats.total_lines)) * 100
                filename = filestats.sourcefile.path.replace("/", "_") + ".html"
                tbody.append(
                    tag.tr(
                        tag.td(tag.a(filestats.sourcefile.path, href=filename)),
                        tag.td(tag.div(tag.div(style="width: %dpx;" % coverage), {"class": "meter"})),
                        tag.td("%.1f%%" % coverage),
                        tag.td("%d/%d lines" % (filestats.executed_lines, filestats.total_lines))))

            f.write(toxml(table, pretty_print=True))
            f.write(ShcovReport.html_end)

        # Create a html file for every source file.
        line_class = {
            ShcovFileStats.LINE_COV: "cov",
            ShcovFileStats.LINE_UNCOV: "uncov",
            ShcovFileStats.LINE_NOCODE: "nocode"
            }

        for filestats in self.file_stats:
            filename = os.path.join(self.out_dir, filestats.sourcefile.path.replace("/", "_") + ".html")
            with open(filename, "w+") as f:
                f.write(ShcovReport.html_start)
                coverage = ((float(filestats.executed_lines) / float(filestats.total_lines)) * 100)
                div = tag.div(
                    tag.h1("SHCOV"),
                    tag.hr(),
                    tag.table(
                        tag.tr(tag.th("Filename:"), tag.td(filestats.sourcefile.path)),
                        tag.tr(tag.th("Date:"), tag.td(time.strftime("%Y-%m-%d"))),
                        tag.tr(tag.th("Code covered:"), tag.td("%.1f%%" % coverage)),
                        tag.tr(tag.th("Instrumented lines:"), tag.td(str(filestats.total_lines))),
                        tag.tr(tag.th("Executed lines:"), tag.td(str(filestats.executed_lines))),
                        {"class": "info"}
                        ),
                    tag.hr()
                    )
                f.write(toxml(div, pretty_print=True))

                pre = tag.pre()
                lineno = 1
                # lineno column shouldn't be wider than the longest line.
                lineno_format = "%%%dd" % len(str(len(filestats.sourcecode)))
                for linetype, line in filestats.sourcecode:
                    count = filestats.sourcefile.lines[lineno] if lineno in filestats.sourcefile.lines else ""
                    pre.append(tag.span(lineno_format % lineno, {"class": "lineno"}))
                    pre.append(tag.span("%8s | " % count, {"class": line_class[linetype]}))
                    pre.append(tag.span("%s\n" % line, {"class": line_class[linetype]}))
                    lineno = lineno + 1
                f.write(toxml(pre))

                f.write(ShcovReport.html_end)

if __name__ == "__main__":
    usage = """%prog [--help]

Example:

  %prog data_directory output_directory.

Output formats:

  text                  Text output where each file has a coverage percentage.
  flat_html
"""
    parser = optparse.OptionParser(usage=usage)
    parser.add_option("--format", dest="format",
                      help="The output style of the report. (text|flat_html)", default="text")
    parser.add_option("--script-base", dest="script_base",
                      help="Source code path", default=None)
    parser.add_option("--data-dir", dest="data_dir", help="Data directory (MANDATORY)")
    parser.add_option("--out-dir", dest="out_dir", help="Out directory (MANDATORY)")
    options, args = parser.parse_args()

    if len(args) != 2:
        print("Incorrect number of arguments.")
        sys.exit(1)

    r = ShcovReport(options.script_base, args[0], args[1])
    r.process()

    # The name of the format is actually a function name to call. So lets look it up and
    # call it.
    if not hasattr(r, options.format):
        print("Invalid format")
        sys.exit(1)
    f = getattr(r, options.format)
    f()
